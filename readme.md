# Лабораторная 1 - MPI

## Замер времени работы
Так как существует слишком много факторов, от которых зависит время работы. Мы попробуем подойти серьезно и замерять время не на одном запуске, а на N запусках (default: 10) и брать среднее. Результатом такого запуска является .csv файл с колонками `threads,pi,points_number,time`.

Для наглядности в этом же скрипте мы строим и графики.

Сам python скрипт: [measure_time.py](measure_time.py). 

**Пример запуска:**
```
python3 measure_time.py --filename first.c --output first.csv
```

**Параметры:**
- `--filename` - Path to code file (e.g., first.c) to run (required)
- `--retries` - Number of retries (default: 10)
- `--output` - File for stats (default: stats.csv)

## Задание 1. Вычисление числа пи
Код: [first.c](first.c)

## Задание 3. Алгоритм Кэннона
Код: [third.c](third.c)

В коде данной задачи реализован параллельный алгоритм Кэннона для умножения плотных квадратных матриц. Основная идея заключается в распределении матриц по квадратной сетке процессов с последующими циклическими сдвигами блоков.
  
**Особенности:**
- **Требует квадратную сетку процессов**: √p × √p, где p — количество процессов
- **Минимальная коммуникация**: каждый блок передается только соседним процессам
- **Вычислительная сложность на процесс**: O(n³/p) 
### Графики замеров
![](/third_graph.png)
### Выводы
Метод умножения матриц с использованием алгоритма Кэннона эффективно выполняет свою задачу, исходя из измерений можно сделать следующие выводы:
- Ускорение заметно усиливается после 400 точек: чем крупнее задача, тем сильнее разница между серийным и параллельным запуском.
- Масштабирование параллельного решения для средних и больших размеров достаточно эффективно эффективность 1 потока равна 0.9-0.92, однако на небольших задачах видны накладные расходы.


