# Лабораторная 1 - MPI

Результаты в папке [results/](results)

## Задание 1. Вычисление числа пи

На каждом процессе независимо брали случайные точки внутри квадрата (points_number / comm_sz + остаток), в который вписана единичная окружность (srand был разный для разных процессов). Рассчитывали количество попаданий в окружность.

С помощью MPI_Reduce складывали количество попаданий по всем процессам:

```
MPI_Reduce(&localIns, &totalIns, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
```

### Графики замеров
![](/results/first_graph.png)

### Выводы


Для проверки корректности - в итоговый .csv файл так же записывали значение числа Пи для разных количеств потоков и точек.

Код: [first.c](first.c)

---

## Задание 2. Умножение матрицы на вектор. Разбиение по строкам, столбцам, блокам

#### Разбиение по строкам

Самое простое разбиение: используем MPI_Scatterv с предзаполненными
- sizes - количество элементов подотрезка в памяти - берем количество строк / количество процессов (+ остаток, если число строк не делится на число процессов)
- displs - массив начал подотрезков в памяти - соответственно, берем префикс суммы по sizes

Умножение - просто как строка матрицы на вектор.

#### Разбиение по столбцам

Используем MPI_Type_vector размера (количество строк, 1) с промежутком в количество столбцов между каждым элементом. А также MPI_Type_create_resized, с помощью которого нашу матрицу представляем как набор MPI_Type векторов.

Заполняем матрицу и получаем локальные матрицы (они могут быть из нескольких столбцов) через 
```
MPI_Scatterv(temp, sizes, displs, column_type,
             local_matrix, row_size * sizes[my_rank], MPI_INT, 0, MPI_COMM_WORLD);
```

При умножении - высчитываем индексы и в результате получаем вектор значений размера (количество строк, 1), их нужно сложить по всем процессам с помощью MPI_Reduce.

#### Разбиение по блокам

Используем виртуальную топологию (Декартову решетку) и MPI_Scatterv, чтобы корректно рассылать матрицы по процессам.

При умножении - опять высчитываем индексы (на основе текущих MPI_Cart_coords и размеров блока) и получаем вектор размера (количество строк, 1), их нужно сложить по всем процессам с помощью MPI_Reduce.

### Графики замеров
![](/results/second_graph.png)

### Выводы

Для проверки корректности - в итоговый .csv файл так же записывали значение суммы чисел в итоговом векторе.

Код: [second_rows.c](second_rows.c)
Код: [second_columns.c](second_columns.c)
Код: [second_blocks.c](second_blocks.c)

---

## Задание 3. Алгоритм Кэннона
Код: [third.c](third.c)

В коде данной задачи реализован параллельный алгоритм Кэннона для умножения плотных квадратных матриц. Основная идея заключается в распределении матриц по квадратной сетке процессов с последующими циклическими сдвигами блоков.
  
**Особенности:**
- **Требует квадратную сетку процессов**: √p × √p, где p — количество процессов
- **Минимальная коммуникация**: каждый блок передается только соседним процессам
- **Вычислительная сложность на процесс**: O(n³/p) 
### Графики замеров
![](/results/third_graph.png)
### Выводы
Метод умножения матриц с использованием алгоритма Кэннона эффективно выполняет свою задачу, исходя из измерений можно сделать следующие выводы:
- Ускорение заметно усиливается после 400 точек: чем крупнее задача, тем сильнее разница между серийным и параллельным запуском.
- Масштабирование параллельного решения для средних и больших размеров достаточно эффективно эффективность 1 потока равна 0.9-0.92, однако на небольших задачах видны накладные расходы.

---

## Замер времени работы
Так как существует слишком много факторов, от которых зависит время работы. Мы попробуем подойти серьезно и замерять время не на одном запуске, а на N запусках (default: 10) и брать среднее. Результатом такого запуска является .csv файл с колонками `threads,pi,points_number,time`.

Для наглядности в этом же скрипте мы строим и графики.

Сам python скрипт: [measure_time.py](measure_time.py). 

**Пример запуска:**
```
python3 measure_time.py --filename first.c --output first.csv
```

**Параметры:**
- `--filename` - Path to code file (e.g., first.c) to run (required)
- `--retries` - Number of retries (default: 10)
- `--output` - File for stats (default: stats.csv)
